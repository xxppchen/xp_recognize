Index: Features/features.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom Features.base_features import BaseFeatures\r\nfrom Features.expert_features import ExpertFeatures\r\n\r\n\r\nclass Features:\r\n    \"\"\"\r\n    基础特征类，继承于FeaturesPar类，用于计算一段较长数据，对长数据进行分段从而得到一系列特征序列\r\n    \"\"\"\r\n\r\n    def __init__(self, sampling_frequency, eval_per=0.02, use_periods=1, is_fft=False,\r\n                 is_wavelet=False, wt_level=0, wt_name='db3'):\r\n        \"\"\"BaseFeatures类的初始化\r\n\r\n        :param sampling_frequency: 采样频率，当要进行傅里叶变换即is_fft为True时需指定\r\n        :param eval_per: 每多长时间进行一次计算，默认为每0.02s计算一次\r\n        :param use_periods: 每次计算使用多少个周期，默认为1周期\r\n        :param is_fft: 是否进行傅里叶计算，True时结果在属性data_fft中\r\n        :param is_wavelet: 是否需要进行小波变换相关计算，True时结果在属性data_wt中\r\n        :param wt_level: 小波变换层数，当要进行小波变换时需指定\r\n        :param wt_name: 小波名称，默认为db3，可修改\r\n        \"\"\"\r\n        self.sampling_frequency = sampling_frequency\r\n        self.power_frequency = 50  # 电源频率\r\n        self.num_per_periods = int(self.sampling_frequency / self.power_frequency)\r\n        self.is_fft = is_fft\r\n        self.is_wavelet = is_wavelet\r\n        if self.is_wavelet:\r\n            if wt_level == 0:\r\n                # 若要做小波变换，则需确定小波种类和分析的阶数，否则抛出错误\r\n                raise Exception('请确定小波变换阶数（wt_level）的值，必要时修改小波种类，以便进行小波计算')\r\n            else:\r\n                self.wt_level = wt_level\r\n                self.wt_name = wt_name\r\n        self.eval_per = eval_per\r\n        self.use_periods = use_periods\r\n        self.__base_feature = BaseFeatures(is_fft, False, sampling_frequency, wt_level, wt_name)\r\n        self.__expert_feature = ExpertFeatures(is_fft, sampling_frequency)\r\n\r\n    def __call__(self, data_i, data_u=None):\r\n        \"\"\"获取各种特征序列\r\n\r\n        :param data_i: 电流数据\r\n        :param data_u: 电压数据，当不输入电压数据时，只计算电流数据\r\n        :return:\r\n        \"\"\"\r\n        data_i = np.array(data_i)\r\n        self.__data_i = data_i  # 原始电流数据\r\n        self.__data_i_mean_list = []  # 电流数据平均值列表\r\n        self.__data_i_pp_list = []  # 电流数据峰峰值列表\r\n        self.__data_i_rms_list = []  # 电流数据有效值列表\r\n        self.__data_i_wave_factor_list = []  # 电流数据波形因数列表\r\n        self.__data_i_pp_rms_list = []  # 电流数据峰均比列表\r\n        self.__data_i_thd_list = []\r\n        self.__data_fft_list = {\"hm\": [], \"hp\": []}\r\n        self.__data_wt_whole = None  # 电流数据的小波分析\r\n        # 整段数据切成数组，并通过BaseFeatures类依次append\r\n        self.cut_data_i = self.__cut_data(data_i)  # 分段后的电流数据\r\n        for i in range(len(self.cut_data_i)):\r\n            self.__base_feature(self.cut_data_i[i])\r\n            self.__data_i_mean_list.append(self.__base_feature.data_mean)\r\n            self.__data_i_pp_list.append(self.__base_feature.data_pp)\r\n            self.__data_i_rms_list.append(self.__base_feature.data_rms)\r\n            self.__data_i_wave_factor_list.append(self.__base_feature.data_wave_factor)\r\n            self.__data_i_pp_rms_list.append(self.__base_feature.data_pp_rms)\r\n            if self.is_fft and self.__base_feature.data_fft is not None and data_u is None:\r\n                self.__data_fft_list[\"hm\"].append(self.__base_feature.data_fft[\"hm\"])\r\n                self.__data_fft_list[\"hp\"].append(self.__base_feature.data_fft[\"hp\"])\r\n                self.__data_i_thd_list.append(self.__base_feature.data_thd)\r\n        if self.is_wavelet:\r\n            self.__data_wt_whole = BaseFeatures.get_wt_data(self.__data_i, self.wt_name, self.wt_level)\r\n\r\n        self.__data_u = None\r\n        self.__data_u_mean_list = []  # 电压数据平均值列表\r\n        self.__data_u_pp_list = []  # 电压数据峰峰值列表\r\n        self.__data_u_rms_list = []  # 电压数据有效值列表\r\n        self.__data_u_wave_factor_list = []  # 电压数据波形因数列表\r\n        self.__data_u_pp_rms_list = []  # 电压数据峰均比列表\r\n        self.__P_list = []  # 有功功率列表\r\n        self.__S_list = []  # 视在功率列表\r\n        self.__Q_list = []  # 无功功率列表\r\n        self.__P_F_list = []  # 功率因数列表\r\n        self.__u_i_fft_list = {\"U_hm\": [], \"U_hp\": [], \"I_hm\": [], \"I_hp\": [], \"Z_hm\": [], \"Z_hp\": []}  # 电压电流FFT结果列表\r\n        if data_u is not None:\r\n            data_u = np.array(data_u)\r\n            self.data_p = data_u * data_i\r\n            self.__data_u = data_u  # 原始电压数据\r\n            self.cut_data_u = self.__cut_data(data_u)  # 分段后的电压数据\r\n            for i in range(len(self.cut_data_u)):\r\n                self.__base_feature(self.cut_data_u[i])\r\n                self.__data_u_mean_list.append(self.__base_feature.data_mean)\r\n                self.__data_u_pp_list.append(self.__base_feature.data_pp)\r\n                self.__data_u_rms_list.append(self.__base_feature.data_rms)\r\n                self.__expert_feature(self.cut_data_u[i], self.cut_data_i[i])\r\n                self.__P_list.append(self.__expert_feature.P)\r\n                self.__S_list.append(self.__expert_feature.S)\r\n                self.__Q_list.append(self.__expert_feature.Q)\r\n                self.__P_F_list.append(self.__expert_feature.P_F)\r\n                if self.is_fft and self.__expert_feature.u_i_fft:\r\n                    self.__u_i_fft_list[\"U_hm\"].append(self.__expert_feature.u_i_fft[\"U_hm\"])\r\n                    self.__u_i_fft_list[\"U_hp\"].append(self.__expert_feature.u_i_fft[\"U_hp\"])\r\n                    self.__u_i_fft_list[\"I_hm\"].append(self.__expert_feature.u_i_fft[\"I_hm\"])\r\n                    self.__u_i_fft_list[\"I_hp\"].append(self.__expert_feature.u_i_fft[\"I_hp\"])\r\n                    self.__u_i_fft_list[\"Z_hm\"].append(self.__expert_feature.u_i_fft[\"U_hm\"])\r\n                    self.__u_i_fft_list[\"Z_hp\"].append(self.__expert_feature.u_i_fft[\"Z_hp\"])\r\n        return self\r\n\r\n    def __cut_data(self, data):\r\n        \"\"\"对一段数据分为几段相同长度数据\r\n\r\n        :param data: 要进行分段的数据\r\n        :return: 分段后的数据\r\n        \"\"\"\r\n        data = np.array(data)\r\n        cut_data = []\r\n        eval_per_num = int(self.sampling_frequency * self.eval_per)\r\n        used_num = int(self.num_per_periods * self.use_periods)\r\n        for i in range(int((len(data) - used_num) / eval_per_num) + 1):\r\n            cut_data.append(data[i * eval_per_num:i * eval_per_num + used_num])\r\n        return cut_data\r\n\r\n    @property\r\n    def data_i(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_i\r\n\r\n    @property\r\n    def data_i_mean_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_i_mean_list\r\n\r\n    @property\r\n    def data_i_pp_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_i_pp_list\r\n\r\n    @property\r\n    def data_i_rms_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_i_rms_list\r\n\r\n    @property\r\n    def data_i_wave_factor_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_i_wave_factor_list\r\n\r\n    @property\r\n    def data_i_pp_rms_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_i_pp_rms_list\r\n\r\n    @property\r\n    def data_wt_whole(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_wt_whole\r\n\r\n    @property\r\n    def data_fft_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_fft_list\r\n\r\n    @property\r\n    def data_i_thd_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_i_thd_list\r\n\r\n    @property\r\n    def data_u(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_u\r\n\r\n    @property\r\n    def data_u_mean_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_u_mean_list\r\n\r\n    @property\r\n    def data_u_pp_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_u_pp_list\r\n\r\n    @property\r\n    def data_u_rms_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_u_rms_list\r\n\r\n    @property\r\n    def data_u_wave_factor_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_u_wave_factor_list\r\n\r\n    @property\r\n    def data_u_pp_rms_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_u_pp_rms_list\r\n\r\n    @property\r\n    def P_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__P_list\r\n\r\n    @property\r\n    def S_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__S_list\r\n\r\n    @property\r\n    def Q_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__Q_list\r\n\r\n    @property\r\n    def P_F_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__P_F_list\r\n\r\n    @property\r\n    def u_i_fft_list(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__u_i_fft_list\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Features/features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ Features/features.py	(date 1614847247447)
@@ -8,7 +8,7 @@
     基础特征类，继承于FeaturesPar类，用于计算一段较长数据，对长数据进行分段从而得到一系列特征序列
     """
 
-    def __init__(self, sampling_frequency, eval_per=0.02, use_periods=1, is_fft=False,
+    def __init__(self, sampling_frequency, power_frequency=60, eval_per=0.02, use_periods=1, is_fft=False,
                  is_wavelet=False, wt_level=0, wt_name='db3'):
         """BaseFeatures类的初始化
 
@@ -21,10 +21,11 @@
         :param wt_name: 小波名称，默认为db3，可修改
         """
         self.sampling_frequency = sampling_frequency
-        self.power_frequency = 50  # 电源频率
+        self.power_frequency = power_frequency  # 电源频率
         self.num_per_periods = int(self.sampling_frequency / self.power_frequency)
         self.is_fft = is_fft
         self.is_wavelet = is_wavelet
+        self.data_len = 0
         if self.is_wavelet:
             if wt_level == 0:
                 # 若要做小波变换，则需确定小波种类和分析的阶数，否则抛出错误
@@ -34,8 +35,8 @@
                 self.wt_name = wt_name
         self.eval_per = eval_per
         self.use_periods = use_periods
-        self.__base_feature = BaseFeatures(is_fft, False, sampling_frequency, wt_level, wt_name)
-        self.__expert_feature = ExpertFeatures(is_fft, sampling_frequency)
+        self.__base_feature = BaseFeatures(is_fft=is_fft, sampling_frequency=sampling_frequency)
+        self.__expert_feature = ExpertFeatures(is_fft=is_fft, sampling_frequency=sampling_frequency)
 
     def __call__(self, data_i, data_u=None):
         """获取各种特征序列
@@ -56,6 +57,12 @@
         self.__data_wt_whole = None  # 电流数据的小波分析
         # 整段数据切成数组，并通过BaseFeatures类依次append
         self.cut_data_i = self.__cut_data(data_i)  # 分段后的电流数据
+        self.data_len = len(self.cut_data_i)
+        # 若有输入电压则令basefeature的is_fft设为false，以免重复计算fft，反之设为true
+        if data_u is None:
+            self.__base_feature.is_fft = True
+        else:
+            self.__base_feature.is_fft = False
         for i in range(len(self.cut_data_i)):
             self.__base_feature(self.cut_data_i[i])
             self.__data_i_mean_list.append(self.__base_feature.data_mean)
@@ -103,6 +110,7 @@
                     self.__u_i_fft_list["I_hp"].append(self.__expert_feature.u_i_fft["I_hp"])
                     self.__u_i_fft_list["Z_hm"].append(self.__expert_feature.u_i_fft["U_hm"])
                     self.__u_i_fft_list["Z_hp"].append(self.__expert_feature.u_i_fft["Z_hp"])
+                    self.__data_i_thd_list.append(self.__expert_feature.data_i_thd)
         return self
 
     def __cut_data(self, data):
Index: MyDataset.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from torch.utils.data import Dataset\r\nfrom enum import Enum\r\nimport os\r\nimport json\r\nimport numpy as np\r\nimport copy\r\n\r\n__all__ = [\"LabelType\", \"MyDataset\"]\r\n\r\n\r\nclass LabelType(Enum):\r\n    Type = \"type\"\r\n    Location = \"location\"\r\n    Load = \"load\"\r\n    Status = \"status\"\r\n\r\n\r\ndef clean_meta(ist):\r\n    \"\"\"remove '' elements in Meta Data \"\"\"\r\n    ist_meta = copy.deepcopy(ist)\r\n    ist_temp = copy.deepcopy(ist_meta['appliance'])\r\n    for k, v in ist_temp.items():\r\n        if len(v) == 0:\r\n            del ist_meta['appliance'][k]\r\n    return ist_meta\r\n\r\n\r\ndef parse_meta(meta):\r\n    \"\"\"parse meta data for easy access\"\"\"\r\n    ms = {}\r\n    for k, v in meta.items():\r\n        ms[k] = clean_meta(v)  # 删除空信息\r\n    return ms\r\n\r\n\r\ndef get_dic_value_by_k(dict_, k):\r\n    if k.value in dict_:\r\n        return dict_[k.value]\r\n    else:\r\n        for v in dict_.values():\r\n            if isinstance(v, dict):\r\n                value = get_dic_value_by_k(v, k)\r\n                if value is not None:\r\n                    return value\r\n        return None\r\n\r\n\r\ndef get_label_list(metas, label_type):\r\n    encode_list = {}\r\n    Labels = [get_dic_value_by_k(x, label_type) for x in metas.values()]\r\n    Unq_Label = list(set(Labels))\r\n    Unq_Label.sort()\r\n    for i, label in enumerate(Unq_Label):\r\n        encode_list[label] = i\r\n    return encode_list\r\n\r\n\r\nclass MyDataset(Dataset):\r\n    def __init__(self, meta_path, meta_name, csv_path, label_type):\r\n        super(MyDataset, self).__init__()\r\n        self.meta_path = meta_path\r\n        self.csv_path = csv_path\r\n        self.csv_files = os.listdir(csv_path)\r\n        with open(meta_path + meta_name) as data_file:\r\n            meta = json.load(data_file)\r\n        self.Metas = parse_meta(meta)\r\n        self.label_type = label_type\r\n        self.encode_list = get_label_list(self.Metas, label_type)\r\n\r\n    def __getitem__(self, index):\r\n        app_item_id = str(index + 1)\r\n        app_item = self.Metas[str(index + 1)]\r\n        label_name = get_dic_value_by_k(app_item, self.label_type)\r\n        label = self.encode_list[label_name]\r\n        item_data = np.genfromtxt(self.csv_path + str(app_item_id) + '.csv',\r\n                                  delimiter=',', names='current,voltage', dtype=(float, float))\r\n        # 进行数据预处理在此处进行\r\n        return item_data, label\r\n\r\n    def __len__(self):\r\n        return len(self.csv_files)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- MyDataset.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ MyDataset.py	(date 1614850787826)
@@ -1,6 +1,7 @@
 from torch.utils.data import Dataset
 from enum import Enum
 import os
+import pandas as pd
 import json
 import numpy as np
 import copy
@@ -12,7 +13,11 @@
     Type = "type"
     Location = "location"
     Load = "load"
-    Status = "status"
+    # Status = "status"
+    Is_heat = "is_heat"
+    Is_cold = "is_cool"
+    Is_rotate = "is_rotate"
+    Is_light = "is_light"
 
 
 def clean_meta(ist):
@@ -47,35 +52,42 @@
 
 def get_label_list(metas, label_type):
     encode_list = {}
-    Labels = [get_dic_value_by_k(x, label_type) for x in metas.values()]
-    Unq_Label = list(set(Labels))
-    Unq_Label.sort()
-    for i, label in enumerate(Unq_Label):
+    labels = [get_dic_value_by_k(x, label_type) for x in metas.values()]
+    unq_label = list(set(labels))
+    unq_label.sort()
+    for i, label in enumerate(unq_label):
         encode_list[label] = i
     return encode_list
 
 
 class MyDataset(Dataset):
-    def __init__(self, meta_path, meta_name, csv_path, label_type):
+    def __init__(self, meta_path, csv_path, label_type, used_feas=None):
         super(MyDataset, self).__init__()
         self.meta_path = meta_path
         self.csv_path = csv_path
-        self.csv_files = os.listdir(csv_path)
-        with open(meta_path + meta_name) as data_file:
+        with open(meta_path) as data_file:
             meta = json.load(data_file)
         self.Metas = parse_meta(meta)
         self.label_type = label_type
+        # 标签编号对应列表
         self.encode_list = get_label_list(self.Metas, label_type)
+        feas = pd.read_csv(csv_path, header=None, nrows=1).values
+        if used_feas is None:
+            self.csv_data = pd.read_csv(csv_path, sep=',')
+        else:
+            used_feas = list(used_feas)
+            used_feas = ['id'] + used_feas
+            self.csv_data = pd.read_csv(csv_path, sep=',', usecols=used_feas)
 
     def __getitem__(self, index):
-        app_item_id = str(index + 1)
-        app_item = self.Metas[str(index + 1)]
+        # 获取该数据的标签编码
+        app_item_id = int(self.csv_data["id"][index])
+        app_item = self.Metas[str(app_item_id + 1)]
         label_name = get_dic_value_by_k(app_item, self.label_type)
         label = self.encode_list[label_name]
-        item_data = np.genfromtxt(self.csv_path + str(app_item_id) + '.csv',
-                                  delimiter=',', names='current,voltage', dtype=(float, float))
+        item_data = self.csv_data.iloc[index, 1:]
         # 进行数据预处理在此处进行
         return item_data, label
 
     def __len__(self):
-        return len(self.csv_files)
+        return len(self.csv_data)
Index: Features/expert_features.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom Features.base_features import BaseFeatures\r\n\r\n\r\nclass ExpertFeatures:\r\n    \"\"\"\r\n    专家特征类，用于计算电压电流组合特征\r\n    \"\"\"\r\n\r\n    def __init__(self, is_fft=False, sampling_frequency=0):\r\n        \"\"\"ExpertFeatures类的初始化\r\n\r\n        :param is_fft: 是否进行傅里叶计算，True时结果在属性data_fft中\r\n        :param sampling_frequency: 采样频率，当要进行傅里叶变换即is_fft为True时需指定\r\n        \"\"\"\r\n        self.power_frequency = 50  # 电源频率\r\n        self.__is_fft = is_fft\r\n        if self.__is_fft:\r\n            if sampling_frequency == 0:\r\n                # 若要做fft，则需确定采样频率的值，否则抛出错误\r\n                raise Exception('请确定采样频率（sampling_frequency）的值，以便进行FFT计算')\r\n            else:\r\n                self.sampling_frequency = sampling_frequency\r\n\r\n    def __call__(self, data_u, data_i):\r\n        \"\"\"更新实例的特征\r\n\r\n        :param data_u: 要计算的原始电压数据\r\n        :param data_i: 要计算的原始电流数据\r\n        :return: 更新完各特征的实例\r\n        \"\"\"\r\n        data_u = np.array(data_u)\r\n        data_i = np.array(data_i)\r\n        self.data_p = data_u * data_i\r\n        self.__source_data_u = data_u  # 原始电压数据\r\n        self.__source_data_i = data_i  # 原始电流数据\r\n        self.__P = self.get_P(data_u, data_i)  # 计算有功功率\r\n        self.__S = self.get_S(data_u, data_i)  # 计算视在功率\r\n        self.__Q = np.sqrt(np.square(self.S) - np.square(self.P))  # 计算无功功率\r\n        self.__P_F = self.get_factor(data_u, data_i)  # 计算功率因数\r\n        self.__u_i_fft = None\r\n        if self.__is_fft:\r\n            self.__u_i_fft = self.get_ui_harmonic(data_u, data_i, self.sampling_frequency, self.power_frequency)\r\n        return self\r\n\r\n    @staticmethod\r\n    def get_P(u_data, i_data):\r\n        \"\"\"计算有功功率\r\n\r\n        :param u_data: 原始电压数据\r\n        :param i_data: 原始电流数据\r\n        :return: 有功功率\r\n        \"\"\"\r\n        return np.mean(i_data * u_data)\r\n\r\n    @staticmethod\r\n    def get_S(u_data, i_data):\r\n        \"\"\"计算视在功率\r\n\r\n        :param u_data: 原始电压数据\r\n        :param i_data: 原始电流数据\r\n        :return: 视在功率\r\n        \"\"\"\r\n        return BaseFeatures.get_rms(i_data) * BaseFeatures.get_rms(u_data)\r\n\r\n    @staticmethod\r\n    def get_Q(u_data, i_data):\r\n        \"\"\"计算无功功率\r\n\r\n        :param u_data: 原始电压数据\r\n        :param i_data: 原始电流数据\r\n        :return: 无功功率\r\n        \"\"\"\r\n        s = ExpertFeatures.get_S(u_data, i_data)\r\n        p = ExpertFeatures.get_P(u_data, i_data)\r\n        return np.sqrt(s * s - p * p)\r\n\r\n    @staticmethod\r\n    def get_factor(u_data, i_data):\r\n        \"\"\"计算功率因数\r\n\r\n        :param u_data: 原始电压数据\r\n        :param i_data: 原始电流数据\r\n        :return: 功率因数\r\n        \"\"\"\r\n        return ExpertFeatures.get_P(i_data, u_data) / ExpertFeatures.get_S(i_data, u_data)\r\n\r\n    @staticmethod\r\n    def get_ui_harmonic(u_data, i_data, sampling_frequency, power_frequency):\r\n        \"\"\"对原始电压电流数据进行傅里叶变换，结果以电压基波为基准\r\n\r\n        :param u_data: 原始电压波形\r\n        :param i_data: 原始电流波形\r\n        :param sampling_frequency: 采样频率\r\n        :param power_frequency: 电源频率\r\n        :return: 傅里叶计算结果\r\n        \"\"\"\r\n        u_data = np.array(u_data)\r\n        i_data = np.array(i_data)\r\n        freq, u_hm, u_hp = BaseFeatures.fft_to_harmonic(u_data, sampling_frequency, power_frequency)\r\n        freq, i_hm, i_hp = BaseFeatures.fft_to_harmonic(i_data, sampling_frequency, power_frequency)\r\n        # 改为以电压基波为基准，即电压基波相位为0\r\n        for i in range(1, 32):\r\n            if i_hm[i] != 0:\r\n                i_hp[i] -= i * u_hp[1]\r\n            while i_hp[i] < 0:\r\n                i_hp[i] += 360\r\n            while i_hp[i] > 360:\r\n                i_hp[i] -= 360\r\n        for i in range(2, 32):\r\n            if u_hm[i] != 0:\r\n                u_hp[i] -= i * u_hp[1]\r\n            while u_hp[i] < 0:\r\n                u_hp[i] += 360\r\n            while u_hp[i] >= 360:\r\n                u_hp[i] -= 360\r\n        u_hp[1] = 0\r\n        # 将电流对齐到电压操作\r\n        harmonic = {\r\n            \"freq\": freq,\r\n            \"U_hm\": u_hm,\r\n            \"U_hp\": u_hp,\r\n            \"I_hm\": i_hm,\r\n            \"I_hp\": i_hp,\r\n            \"Z_hm\": u_hm / i_hm,\r\n            \"Z_hp\": u_hp - i_hp\r\n        }\r\n        return harmonic\r\n\r\n    @property\r\n    def source_data_u(self):\r\n        return self.__source_data_u\r\n\r\n    @property\r\n    def source_data_i(self):\r\n        return self.__source_data_i\r\n\r\n    @property\r\n    def P(self):\r\n        return self.__P\r\n\r\n    @property\r\n    def S(self):\r\n        return self.__S\r\n\r\n    @property\r\n    def Q(self):\r\n        return self.__Q\r\n\r\n    @property\r\n    def P_F(self):\r\n        return self.__P_F\r\n\r\n    @property\r\n    def u_i_fft(self):\r\n        return self.__u_i_fft\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Features/expert_features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ Features/expert_features.py	(date 1614847430608)
@@ -7,13 +7,13 @@
     专家特征类，用于计算电压电流组合特征
     """
 
-    def __init__(self, is_fft=False, sampling_frequency=0):
+    def __init__(self, power_frequency=60, is_fft=False, sampling_frequency=0):
         """ExpertFeatures类的初始化
 
         :param is_fft: 是否进行傅里叶计算，True时结果在属性data_fft中
         :param sampling_frequency: 采样频率，当要进行傅里叶变换即is_fft为True时需指定
         """
-        self.power_frequency = 50  # 电源频率
+        self.power_frequency = power_frequency  # 电源频率
         self.__is_fft = is_fft
         if self.__is_fft:
             if sampling_frequency == 0:
@@ -41,6 +41,7 @@
         self.__u_i_fft = None
         if self.__is_fft:
             self.__u_i_fft = self.get_ui_harmonic(data_u, data_i, self.sampling_frequency, self.power_frequency)
+            self.__data_i_thd = np.mean(np.square((self.__u_i_fft["I_hm"])[2:])) / (self.__u_i_fft["I_hm"])[1]
         return self
 
     @staticmethod
@@ -122,11 +123,16 @@
             "U_hp": u_hp,
             "I_hm": i_hm,
             "I_hp": i_hp,
-            "Z_hm": u_hm / i_hm,
+            "Z_hm": u_hm / (i_hm+0.00001),
             "Z_hp": u_hp - i_hp
         }
         return harmonic
 
+    @property
+    def data_i_thd(self):
+        """设置属性只读"""
+        return self.__data_i_thd
+
     @property
     def source_data_u(self):
         return self.__source_data_u
Index: Features/base_features.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport pywt\r\n\r\n\r\nclass BaseFeatures:\r\n    \"\"\"\r\n    基础特征的父类，包含常见基础特征的计算方法，用于对整段数据进行单次计算\r\n    \"\"\"\r\n\r\n    def __init__(self, is_fft=False, is_wavelet=False, sampling_frequency=0, wt_level=0, wt_name='db3'):\r\n        \"\"\"FeaturesPar类的初始化\r\n\r\n        :param is_fft: 是否进行傅里叶计算，True时结果在属性data_fft中\r\n        :param is_wavelet: 是否需要进行小波变换相关计算，True时结果在属性data_wt中\r\n        :param sampling_frequency: 采样频率，当要进行傅里叶变换即is_fft为True时需指定\r\n        :param wt_level: 小波变换层数，当要进行小波变换时需指定\r\n        :param wt_name: 小波名称，默认为db3，可修改\r\n        \"\"\"\r\n        self.power_frequency = 50  # 电源频率\r\n        self.__is_fft = is_fft\r\n        self.__is_wavelet = is_wavelet\r\n        if self.__is_fft:\r\n            if sampling_frequency == 0:\r\n                # 若要做fft，则需确定采样频率的值，否则抛出错误\r\n                raise Exception('请确定采样频率（sampling_frequency）的值，以便进行FFT计算')\r\n            else:\r\n                self.sampling_frequency = sampling_frequency\r\n        if self.__is_wavelet:\r\n            if wt_level == 0:\r\n                # 若要做小波变换，则需确定小波种类和分析的阶数，否则抛出错误\r\n                raise Exception('请确定小波变换阶数（wt_level）的值，必要时修改小波种类，以便进行小波计算')\r\n            else:\r\n                self.wt_level = wt_level\r\n                self.wt_name = wt_name\r\n\r\n    def __call__(self, data):\r\n        \"\"\"更新实例的特征\r\n\r\n        :param data: 要进行计算的数据\r\n        :return: 更新后的实例\r\n        \"\"\"\r\n        data = np.array(data)\r\n        self.__data_source = data  # 原始数据\r\n        self.__data_mean = self.get_mean(data)  # 数据平均值\r\n        self.__data_pp = self.get_p_p_value(data)  # 数据峰峰值\r\n        self.__data_rms = self.get_rms(data)  # 数据有效值\r\n        self.__data_wave_factor = self.get_wave_factor(data)  # 计算波形因数\r\n        self.__data_pp_rms = self.get_pp_rms(data)  # 计算峰均比\r\n        self.__data_fft = None\r\n        self.__data_wt = None\r\n        self.__data_thd = None\r\n        if self.__is_wavelet:\r\n            self.__data_wt = self.get_wt_data(data, self.wt_name, self.wt_level)\r\n        if self.__is_fft:\r\n            self.__data_fft = {\"freq\": (self.fft_to_harmonic(data, self.sampling_frequency, self.power_frequency))[0],\r\n                               \"hm\": (self.fft_to_harmonic(data, self.sampling_frequency, self.power_frequency))[1],\r\n                               \"hp\": (self.fft_to_harmonic(data, self.sampling_frequency, self.power_frequency))[2]}\r\n            self.__data_thd = np.mean(np.square((self.__data_fft[\"hm\"])[2:]))/(self.__data_fft[\"hm\"])[1]\r\n        return self\r\n\r\n    @property\r\n    def data_source(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_source\r\n\r\n    @property\r\n    def data_mean(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_mean\r\n\r\n    @property\r\n    def data_pp(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_pp\r\n\r\n    @property\r\n    def data_rms(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_rms\r\n\r\n    @property\r\n    def data_wave_factor(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_wave_factor\r\n\r\n    @property\r\n    def data_pp_rms(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_pp_rms\r\n\r\n    @property\r\n    def data_wt(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_wt\r\n\r\n    @property\r\n    def data_fft(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_fft\r\n\r\n    @property\r\n    def data_thd(self):\r\n        \"\"\"设置属性只读\"\"\"\r\n        return self.__data_thd\r\n\r\n    @staticmethod\r\n    def get_mean(data):\r\n        \"\"\"计算数据平均值\r\n\r\n        :param data: 要进行计算平均值的数据\r\n        :return: 平均值\r\n        \"\"\"\r\n        data = np.array(data).reshape(-1)\r\n        return np.mean(data)\r\n\r\n    @staticmethod\r\n    def get_p_p_value(data):\r\n        \"\"\"计算峰峰值\r\n\r\n        :param data: 要进行计算峰峰值的数据\r\n        :return: 峰峰值\r\n        \"\"\"\r\n        data = np.array(data).reshape(-1)\r\n        return np.max(data) - np.min(data)\r\n\r\n    @staticmethod\r\n    def get_rms(data):\r\n        \"\"\"计算有效值\r\n\r\n        :param data: 要进行有效值计算的数据\r\n        :return: 有效值\r\n        \"\"\"\r\n        square_data = np.square(data)\r\n        return np.sqrt(np.mean(square_data))\r\n\r\n    @staticmethod\r\n    def get_wave_factor(data):\r\n        \"\"\"计算波形因数\r\n\r\n        :param data: 要进行波形因数计算的数据\r\n        :return: 波形因数\r\n        \"\"\"\r\n        return BaseFeatures.get_rms(data) / np.mean(np.abs(data))\r\n\r\n    @staticmethod\r\n    def get_pp_rms(data):\r\n        \"\"\"计算均峰比\r\n\r\n        :param data: 要进行均峰比计算的数据\r\n        :return: 均峰比\r\n        \"\"\"\r\n        return BaseFeatures.get_p_p_value(data) / BaseFeatures.get_rms(data)\r\n\r\n    @staticmethod\r\n    def fft_to_harmonic(data, sampling_frequency, power_frequency):\r\n        \"\"\"傅里叶计算\r\n\r\n        :param data: 要进行傅里叶计算的数据\r\n        :param sampling_frequency: 数据的采样频率\r\n        :param power_frequency: 数据的电源频率\r\n        :return: 第1至31次谐波的频率，对应的谐波有效值和谐波相角\r\n        \"\"\"\r\n        data = np.array(data)\r\n        index = np.arange(32) * int(np.size(data, 0) / sampling_frequency * power_frequency)\r\n        x = np.fft.fft(data, np.size(data, 0), axis=0) / np.size(data, 0) * 2\r\n        x = x[index]\r\n        x[0] /= np.sqrt(2)\r\n        freq = np.fft.fftfreq(np.size(data, 0), 1 / sampling_frequency)\r\n        freq = freq[index]\r\n        hp = np.angle(x) / np.pi * 180\r\n        hm = np.abs(x) / np.sqrt(2)\r\n        if hp[0] > 90:\r\n            hp[0] -= 180\r\n            hm[0] = -hm[0]\r\n        return freq, hm, hp\r\n\r\n    @staticmethod\r\n    def get_wt_data(data, wt_name, wave_level):\r\n        \"\"\"离散小波变换计算\r\n\r\n        :param data: 要进行小波变换的数据\r\n        :param wt_name: 所使用的小波基名称\r\n        :param wave_level: 要进行的小波分析层数\r\n        :return: 小波系数和各层小波能量等\r\n        \"\"\"\r\n        coeffs = pywt.wavedec(data, wt_name, level=wave_level)  # 小波系数获取\r\n        cd_list = []\r\n        cd_e_list = []\r\n        for i in range(len(coeffs) - 1):\r\n            cd_list.append(coeffs[len(coeffs) - i - 1])\r\n            cd_e_list.append(np.mean(np.square(coeffs[len(coeffs) - i - 1])))\r\n        wt_result = {\r\n            \"Coeffs\": coeffs,  # 小波系数，coeffs[0]是近似系数，coeffs[1]是最底层细节系数\r\n            \"CA\": coeffs[0],  # 近似小波系数\r\n            \"CD\": cd_list,  # 细节小波系数\r\n            \"CD_E_list\": cd_e_list,  # 各层细节系数能量值\r\n            \"CA_E\": np.mean(np.square(coeffs[0])),  # 近似系数能量\r\n            \"CD_E\": np.sum(cd_e_list)  # 细节系数能量\r\n        }\r\n        return wt_result\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Features/base_features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ Features/base_features.py	(date 1614847061575)
@@ -7,7 +7,7 @@
     基础特征的父类，包含常见基础特征的计算方法，用于对整段数据进行单次计算
     """
 
-    def __init__(self, is_fft=False, is_wavelet=False, sampling_frequency=0, wt_level=0, wt_name='db3'):
+    def __init__(self, power_frequency=60, is_fft=False, is_wavelet=False, sampling_frequency=0, wt_level=0, wt_name='db3'):
         """FeaturesPar类的初始化
 
         :param is_fft: 是否进行傅里叶计算，True时结果在属性data_fft中
@@ -16,10 +16,10 @@
         :param wt_level: 小波变换层数，当要进行小波变换时需指定
         :param wt_name: 小波名称，默认为db3，可修改
         """
-        self.power_frequency = 50  # 电源频率
-        self.__is_fft = is_fft
+        self.power_frequency = power_frequency  # 电源频率
+        self.is_fft = is_fft
         self.__is_wavelet = is_wavelet
-        if self.__is_fft:
+        if self.is_fft:
             if sampling_frequency == 0:
                 # 若要做fft，则需确定采样频率的值，否则抛出错误
                 raise Exception('请确定采样频率（sampling_frequency）的值，以便进行FFT计算')
@@ -51,7 +51,7 @@
         self.__data_thd = None
         if self.__is_wavelet:
             self.__data_wt = self.get_wt_data(data, self.wt_name, self.wt_level)
-        if self.__is_fft:
+        if self.is_fft:
             self.__data_fft = {"freq": (self.fft_to_harmonic(data, self.sampling_frequency, self.power_frequency))[0],
                                "hm": (self.fft_to_harmonic(data, self.sampling_frequency, self.power_frequency))[1],
                                "hp": (self.fft_to_harmonic(data, self.sampling_frequency, self.power_frequency))[2]}
Index: example_mydataset.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from MyDataset import *\r\n\r\nmeta_path = 'D:/Desktop/项目/负荷识别部/Plaid/PLAID 2018/submetered/'\r\nmeta_name = 'metadata_submetered.json'\r\ncsv_path = meta_path + 'submetered_new/'\r\nd = MyDataset(meta_path, meta_name, csv_path, LabelType.Type)\r\ndata, label = d[0]\r\nprint(\"XXX\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- example_mydataset.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ example_mydataset.py	(date 1614850874034)
@@ -1,8 +1,9 @@
 from MyDataset import *
 
-meta_path = 'D:/Desktop/项目/负荷识别部/Plaid/PLAID 2018/submetered/'
-meta_name = 'metadata_submetered.json'
-csv_path = meta_path + 'submetered_new/'
-d = MyDataset(meta_path, meta_name, csv_path, LabelType.Type)
+Dir = 'D:/Desktop/项目/负荷识别部/Plaid/PLAID 2018/submetered/'
+meta_path = Dir + 'metadata_submetered2.0.json'
+csv_path = Dir + 'all_submetered.csv'
+used_feas = ["i_mean", "i_thd", "P", "Q"]
+d = MyDataset(meta_path, csv_path, LabelType.Type, used_feas=used_feas)
 data, label = d[0]
 print("XXX")
\ No newline at end of file
Index: 凡/data/feature_extract/features.py
===================================================================
--- 凡/data/feature_extract/features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ 凡/data/feature_extract/features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
@@ -1,253 +0,0 @@
-#!/home/chaofan/anaconda3/bin/python
-# -*- encoding: utf-8 -*-
-'''
-@Description:       :
-@Date     :2021/01/09 15:14:27
-@Author      :chenxinpei
-@version      :1.0
-'''
-import numpy as np
-from base_features import BaseFeatures
-from expert_features import ExpertFeatures
-
-
-class Features:
-    """
-    基础特征类，继承于FeaturesPar类，用于计算一段较长数据，对长数据进行分段从而得到一系列特征序列
-    """
-    def __init__(self,
-                 sampling_frequency,
-                 eval_per=0.02,
-                 use_periods=1,
-                 is_fft=False,
-                 is_wavelet=False,
-                 wt_level=0,
-                 wt_name='db3'):
-        """BaseFeatures类的初始化
-
-        :param sampling_frequency: 采样频率，当要进行傅里叶变换即is_fft为True时需指定
-        :param eval_per: 每多长时间进行一次计算，默认为每0.02s计算一次
-        :param use_periods: 每次计算使用多少个周期，默认为1周期
-        :param is_fft: 是否进行傅里叶计算，True时结果在属性data_fft中
-        :param is_wavelet: 是否需要进行小波变换相关计算，True时结果在属性data_wt中
-        :param wt_level: 小波变换层数，当要进行小波变换时需指定
-        :param wt_name: 小波名称，默认为db3，可修改
-        """
-        self.sampling_frequency = sampling_frequency
-        self.power_frequency = 60  # 电源频率
-        self.num_per_periods = int(self.sampling_frequency /
-                                   self.power_frequency)
-        self.is_fft = is_fft
-        self.is_wavelet = is_wavelet
-        if self.is_wavelet:
-            if wt_level == 0:
-                # 若要做小波变换，则需确定小波种类和分析的阶数，否则抛出错误
-                raise Exception('请确定小波变换阶数（wt_level）的值，必要时修改小波种类，以便进行小波计算')
-            else:
-                self.wt_level = wt_level
-                self.wt_name = wt_name
-        self.eval_per = eval_per
-        self.use_periods = use_periods
-        self.__base_feature = BaseFeatures(is_fft, False, sampling_frequency,
-                                           wt_level, wt_name)
-        self.__expert_feature = ExpertFeatures(is_fft, sampling_frequency)
-
-    def __call__(self, data_i, data_u=None):
-        """获取各种特征序列
-
-        :param data_i: 电流数据
-        :param data_u: 电压数据，当不输入电压数据时，只计算电流数据
-        :return:
-        """
-        data_i = np.array(data_i)
-        self.__data_i = data_i  # 原始电流数据
-        self.__data_i_mean_list = []  # 电流数据平均值列表
-        self.__data_i_pp_list = []  # 电流数据峰峰值列表
-        self.__data_i_rms_list = []  # 电流数据有效值列表
-        self.__data_i_wave_factor_list = []  # 电流数据波形因数列表
-        self.__data_i_pp_rms_list = []  # 电流数据峰均比列表
-        self.__data_i_thd_list = []
-        self.__data_fft_list = {"hm": [], "hp": []}
-        self.__data_wt_whole = None  # 电流数据的小波分析
-        # 整段数据切成数组，并通过BaseFeatures类依次append
-        self.cut_data_i = self.__cut_data(data_i)  # 分段后的电流数据
-        for i in range(len(self.cut_data_i)):
-            self.__base_feature(self.cut_data_i[i])
-            self.__data_i_mean_list.append(self.__base_feature.mean)
-            self.__data_i_pp_list.append(self.__base_feature.pp)
-            self.__data_i_rms_list.append(self.__base_feature.rms)
-            self.__data_i_wave_factor_list.append(
-                self.__base_feature.wave_factor)
-            self.__data_i_pp_rms_list.append(self.__base_feature.pp_rms)
-            if (self.is_fft and (self.__base_feature.fft is not None)
-                    and (data_u is not None)):
-                self.__data_fft_list["hm"].append(
-                    self.__base_feature.fft["hm"])
-                self.__data_fft_list["hp"].append(
-                    self.__base_feature.fft["hp"])
-                self.__data_i_thd_list.append(self.__base_feature.thd)
-        if self.is_wavelet:
-            self.__data_wt_whole = BaseFeatures.get_wt_data(
-                self.__data_i, self.wt_name, self.wt_level)
-
-        self.__data_u = None
-        self.__data_u_mean_list = []  # 电压数据平均值列表
-        self.__data_u_pp_list = []  # 电压数据峰峰值列表
-        self.__data_u_rms_list = []  # 电压数据有效值列表
-        self.__data_u_wave_factor_list = []  # 电压数据波形因数列表
-        self.__data_u_pp_rms_list = []  # 电压数据峰均比列表
-        self.__P_list = []  # 有功功率列表
-        self.__S_list = []  # 视在功率列表
-        self.__Q_list = []  # 无功功率列表
-        self.__P_F_list = []  # 功率因数列表
-        self.__u_i_fft_list = {
-            "U_hm": [],
-            "U_hp": [],
-            "I_hm": [],
-            "I_hp": [],
-            "Z_hm": [],
-            "Z_hp": []
-        }  # 电压电流FFT结果列表
-        if data_u is not None:
-            data_u = np.array(data_u)
-            self.data_p = data_u * data_i
-            self.__data_u = data_u  # 原始电压数据
-            self.cut_data_u = self.__cut_data(data_u)  # 分段后的电压数据
-            for i in range(len(self.cut_data_u)):
-                self.__base_feature(self.cut_data_u[i])
-                self.__data_u_mean_list.append(self.__base_feature.mean)
-                self.__data_u_pp_list.append(self.__base_feature.pp)
-                self.__data_u_rms_list.append(self.__base_feature.rms)
-                self.__expert_feature(self.cut_data_u[i], self.cut_data_i[i])
-                self.__P_list.append(self.__expert_feature.P)
-                self.__S_list.append(self.__expert_feature.S)
-                self.__Q_list.append(self.__expert_feature.Q)
-                self.__P_F_list.append(self.__expert_feature.P_F)
-                if self.is_fft and self.__expert_feature.u_i_fft:
-                    self.__u_i_fft_list["U_hm"].append(
-                        self.__expert_feature.u_i_fft["U_hm"])
-                    self.__u_i_fft_list["U_hp"].append(
-                        self.__expert_feature.u_i_fft["U_hp"])
-                    self.__u_i_fft_list["I_hm"].append(
-                        self.__expert_feature.u_i_fft["I_hm"])
-                    self.__u_i_fft_list["I_hp"].append(
-                        self.__expert_feature.u_i_fft["I_hp"])
-                    self.__u_i_fft_list["Z_hm"].append(
-                        self.__expert_feature.u_i_fft["Z_hm"])
-                    self.__u_i_fft_list["Z_hp"].append(
-                        self.__expert_feature.u_i_fft["Z_hp"])
-        return self
-
-    def __cut_data(self, data):
-        """对一段数据分为几段相同长度数据
-
-        :param data: 要进行分段的数据
-        :return: 分段后的数据
-        """
-        data = np.array(data)
-        cut_data = []
-        eval_per_num = int(self.sampling_frequency * self.eval_per)  # 采样间隔
-        used_num = int(self.num_per_periods * self.use_periods)  # 采样长度
-        for i in range(int((len(data) - used_num) / eval_per_num) + 1):
-            cut_data.append(data[i * eval_per_num:i * eval_per_num + used_num])
-        return cut_data
-
-    @property
-    def data_i(self):
-        """设置属性只读"""
-        return self.__data_i
-
-    @property
-    def data_i_mean_list(self):
-        """设置属性只读"""
-        return self.__data_i_mean_list
-
-    @property
-    def data_i_pp_list(self):
-        """设置属性只读"""
-        return self.__data_i_pp_list
-
-    @property
-    def data_i_rms_list(self):
-        """设置属性只读"""
-        return self.__data_i_rms_list
-
-    @property
-    def data_i_wave_factor_list(self):
-        """设置属性只读"""
-        return self.__data_i_wave_factor_list
-
-    @property
-    def data_i_pp_rms_list(self):
-        """设置属性只读"""
-        return self.__data_i_pp_rms_list
-
-    @property
-    def data_wt_whole(self):
-        """设置属性只读"""
-        return self.__data_wt_whole
-
-    @property
-    def data_fft_list(self):
-        """设置属性只读"""
-        return self.__data_fft_list
-
-    @property
-    def data_i_thd_list(self):
-        """设置属性只读"""
-        return self.__data_i_thd_list
-
-    @property
-    def data_u(self):
-        """设置属性只读"""
-        return self.__data_u
-
-    @property
-    def data_u_mean_list(self):
-        """设置属性只读"""
-        return self.__data_u_mean_list
-
-    @property
-    def data_u_pp_list(self):
-        """设置属性只读"""
-        return self.__data_u_pp_list
-
-    @property
-    def data_u_rms_list(self):
-        """设置属性只读"""
-        return self.__data_u_rms_list
-
-    @property
-    def data_u_wave_factor_list(self):
-        """设置属性只读"""
-        return self.__data_u_wave_factor_list
-
-    @property
-    def data_u_pp_rms_list(self):
-        """设置属性只读"""
-        return self.__data_u_pp_rms_list
-
-    @property
-    def P_list(self):
-        """设置属性只读"""
-        return self.__P_list
-
-    @property
-    def S_list(self):
-        """设置属性只读"""
-        return self.__S_list
-
-    @property
-    def Q_list(self):
-        """设置属性只读"""
-        return self.__Q_list
-
-    @property
-    def P_F_list(self):
-        """设置属性只读"""
-        return self.__P_F_list
-
-    @property
-    def u_i_fft_list(self):
-        """设置属性只读"""
-        return self.__u_i_fft_list
Index: 凡/data/feature_extract/expert_features.py
===================================================================
--- 凡/data/feature_extract/expert_features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ 凡/data/feature_extract/expert_features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
@@ -1,160 +0,0 @@
-import numpy as np
-from base_features import BaseFeatures
-
-
-class ExpertFeatures:
-    """
-    专家特征类，用于计算电压电流组合特征
-    """
-    def __init__(self, is_fft=False, sampling_frequency=0):
-        """ExpertFeatures类的初始化
-
-        :param is_fft: 是否进行傅里叶计算，True时结果在属性data_fft中
-        :param sampling_frequency: 采样频率，当要进行傅里叶变换即is_fft为True时需指定
-        """
-        self.power_frequency = 60  # 电源频率
-        self.__is_fft = is_fft
-        if self.__is_fft:
-            if sampling_frequency == 0:
-                # 若要做fft，则需确定采样频率的值，否则抛出错误
-                raise Exception('请确定采样频率（sampling_frequency）的值，以便进行FFT计算')
-            else:
-                self.sampling_frequency = sampling_frequency
-
-    def __call__(self, data_u, data_i):
-        """更新实例的特征
-
-        :param data_u: 要计算的原始电压数据
-        :param data_i: 要计算的原始电流数据
-        :return: 更新完各特征的实例
-        """
-        data_u = np.array(data_u)
-        data_i = np.array(data_i)
-        self.data_p = data_u * data_i
-        self.__source_data_u = data_u  # 原始电压数据
-        self.__source_data_i = data_i  # 原始电流数据
-        self.__P = self.get_P(data_u, data_i)  # 计算有功功率
-        self.__S = self.get_S(data_u, data_i)  # 计算视在功率
-        self.__Q = np.sqrt(np.square(self.S) - np.square(self.P))  # 计算无功功率
-        self.__P_F = self.get_factor(data_u, data_i)  # 计算功率因数
-        self.__u_i_fft = None
-        if self.__is_fft:
-            self.__u_i_fft = self.get_ui_harmonic(data_u, data_i,
-                                                  self.sampling_frequency,
-                                                  self.power_frequency)
-        return self
-
-    @staticmethod
-    def get_P(u_data, i_data):
-        """计算有功功率
-
-        :param u_data: 原始电压数据
-        :param i_data: 原始电流数据
-        :return: 有功功率
-        """
-        return np.mean(i_data * u_data)
-
-    @staticmethod
-    def get_S(u_data, i_data):
-        """计算视在功率
-
-        :param u_data: 原始电压数据
-        :param i_data: 原始电流数据
-        :return: 视在功率
-        """
-        return BaseFeatures.get_rms(i_data) * BaseFeatures.get_rms(u_data)
-
-    @staticmethod
-    def get_Q(u_data, i_data):
-        """计算无功功率
-
-        :param u_data: 原始电压数据
-        :param i_data: 原始电流数据
-        :return: 无功功率
-        """
-        s = ExpertFeatures.get_S(u_data, i_data)
-        p = ExpertFeatures.get_P(u_data, i_data)
-        return np.sqrt(s * s - p * p)
-
-    @staticmethod
-    def get_factor(u_data, i_data):
-        """计算功率因数
-
-        :param u_data: 原始电压数据
-        :param i_data: 原始电流数据
-        :return: 功率因数
-        """
-        return ExpertFeatures.get_P(i_data, u_data) / ExpertFeatures.get_S(
-            i_data, u_data)
-
-    @staticmethod
-    def get_ui_harmonic(u_data, i_data, sampling_frequency, power_frequency):
-        """对原始电压电流数据进行傅里叶变换，结果以电压基波为基准
-
-        :param u_data: 原始电压波形
-        :param i_data: 原始电流波形
-        :param sampling_frequency: 采样频率
-        :param power_frequency: 电源频率
-        :return: 傅里叶计算结果
-        """
-        u_data = np.array(u_data)
-        i_data = np.array(i_data)
-        freq, u_hm, u_hp = BaseFeatures.fft_to_harmonic(
-            u_data, sampling_frequency, power_frequency)
-        freq, i_hm, i_hp = BaseFeatures.fft_to_harmonic(
-            i_data, sampling_frequency, power_frequency)
-        # 改为以电压基波为基准，即电压基波相位为0
-        for i in range(1, 32):
-            if i_hm[i] != 0:
-                i_hp[i] -= i * u_hp[1]
-            while i_hp[i] < 0:
-                i_hp[i] += 360
-            while i_hp[i] > 360:
-                i_hp[i] -= 360
-        for i in range(2, 32):
-            if u_hm[i] != 0:
-                u_hp[i] -= i * u_hp[1]
-            while u_hp[i] < 0:
-                u_hp[i] += 360
-            while u_hp[i] >= 360:
-                u_hp[i] -= 360
-        u_hp[1] = 0
-        # 将电流对齐到电压操作
-        harmonic = {
-            "freq": freq,
-            "U_hm": u_hm,
-            "U_hp": u_hp,
-            "I_hm": i_hm,
-            "I_hp": i_hp,
-            "Z_hm": np.true_divide(u_hm, i_hm),
-            "Z_hp": u_hp - i_hp
-        }
-        return harmonic
-
-    @property
-    def source_data_u(self):
-        return self.__source_data_u
-
-    @property
-    def source_data_i(self):
-        return self.__source_data_i
-
-    @property
-    def P(self):
-        return self.__P
-
-    @property
-    def S(self):
-        return self.__S
-
-    @property
-    def Q(self):
-        return self.__Q
-
-    @property
-    def P_F(self):
-        return self.__P_F
-
-    @property
-    def u_i_fft(self):
-        return self.__u_i_fft
Index: 凡/data/feature_extract/extractfeature.py
===================================================================
--- 凡/data/feature_extract/extractfeature.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ 凡/data/feature_extract/extractfeature.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
@@ -1,62 +0,0 @@
-from features import Features
-import os
-import pandas as pd
-import json
-import numpy as np
-
-path = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
-source_dir = 'source/submetered_new'
-process_dir = 'data/source/submetered_process/'
-csv_dir = os.listdir(os.path.join(path, source_dir))
-feature = Features(sampling_frequency=30000,
-                   is_fft=True,
-                   eval_per=1 / 60,
-                   is_wavelet=True,
-                   wt_level=6)
-with open(os.path.join(path, 'source/metadata_submetered.json'),
-          'r',
-          encoding='utf8') as load_f:
-    load_dict = json.load(load_f)
-for i, file in enumerate(csv_dir):
-    soucre_data = pd.read_csv(os.path.join(path, source_dir, file),
-                              names=["I", "U"])
-    feature(soucre_data['I'], soucre_data['U'])
-
-    dataframe = pd.concat([
-        pd.DataFrame({'i_mean': feature.data_i_mean_list}),
-        pd.DataFrame({'i_pp': feature.data_i_pp_list}),
-        pd.DataFrame({'i_rms': feature.data_i_rms_list}),
-        pd.DataFrame({'i_wave_factor': feature.data_i_wave_factor_list}),
-        pd.DataFrame({'i_pp_rms': feature.data_i_pp_rms_list}),
-        pd.DataFrame({'i_thd': feature.data_i_thd_list}),
-        pd.DataFrame({'u_mean': feature.data_u_mean_list}),
-        pd.DataFrame({'u_pp': feature.data_u_pp_list}),
-        pd.DataFrame({'u_rms': feature.data_u_rms_list}),
-        pd.DataFrame({'P': feature.P_list}),
-        pd.DataFrame({'Q': feature.Q_list}),
-        pd.DataFrame({'S': feature.S_list}),
-        pd.DataFrame({'P_F': feature.P_F_list}),
-    ],
-                          axis=1)
-
-    u_hm = np.array(feature.u_i_fft_list['U_hm']).transpose()
-    u_hp = np.array(feature.u_i_fft_list['U_hp']).transpose()
-    i_hm = np.array(feature.u_i_fft_list['I_hm']).transpose()
-    i_hp = np.array(feature.u_i_fft_list['I_hp']).transpose()
-    z_hm = np.array(feature.u_i_fft_list['Z_hm']).transpose()
-    z_hp = np.array(feature.u_i_fft_list['Z_hp']).transpose()
-
-    for times in range(1, u_hm.shape[0]):
-        uhm = pd.DataFrame({'u_hm{}'.format(times): u_hm[times, :]})
-        uhp = pd.DataFrame({'u_hp{}'.format(times): u_hp[times, :]})
-        ihm = pd.DataFrame({'i_hm{}'.format(times): i_hm[times, :]})
-        ihp = pd.DataFrame({'i_hp{}'.format(times): i_hp[times, :]})
-        zhm = pd.DataFrame({'z_hm{}'.format(times): z_hm[times, :]})
-        zhp = pd.DataFrame({'z_hp{}'.format(times): z_hp[times, :]})
-        dataframe = pd.concat([dataframe, uhm, uhp, ihm, ihp, zhm, zhp],
-                              axis=1)
-
-    # type = load_dict[file[0:-4]]['appliance']['type']
-    # dataframe.to_csv(process_dir + type + '_' + file, index=True, sep=',')
-    dataframe.to_csv(process_dir + file, index=True, sep=',')
-    print('正在处理第{}个数据'.format(i))
Index: 凡/model/knowledge_mode/load_type_classify.py
===================================================================
--- 凡/model/knowledge_mode/load_type_classify.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ 凡/model/knowledge_mode/load_type_classify.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
@@ -1,93 +0,0 @@
-import torch.utils.data as Data
-import torch
-import torch.nn as nn
-import numpy as np
-import time
-import sys
-import pandas as pd
-sys.path.append(r'dataset/')
-sys.path.append(r'model/')
-from classifieddata import read_processed_data
-from linear import SingleLayerModel, DoubleLayerModel, MultiLayerModer
-
-
-def confusion_matrix(preds, labels, conf_matrix):
-    for p, l in zip(preds, labels):
-        conf_matrix[p, l] += 1
-    return conf_matrix
-
-
-process_start_time = time.time()
-label_transformer = {'I': 0, 'R': 1, 'NL': 0}
-feature_select = ['P_F', 'z_hp1']
-x, y = read_processed_data('load',
-                           feature_select=feature_select,
-                           direaction=1,
-                           offset=30,
-                           Transformer=label_transformer)
-print('finished reading data, cost %2.2f s' %
-      (time.time() - process_start_time))
-x_mean = np.mean(x, axis=0)
-x_std = np.std(x, axis=0)
-for i in range(len(x)):
-    for j in range(len(x[0])):
-        if x_std[j] != 0:
-            x[i][j] = (x[i][j] - x_mean[j]) / x_std[j]
-
-x_train = torch.tensor(x).float()
-y_train = torch.tensor(y.astype(float)).float()
-
-dataset = Data.TensorDataset(x_train, y_train)
-dataloader = Data.DataLoader(dataset=dataset, batch_size=128, shuffle=True)
-
-model = SingleLayerModel(x_train.size()[1], 2)
-# model = DoubleLayerModel(x_train.size()[1], 3, 2)
-# model = MultiLayerModer(x_train.size()[1], 2)
-optim = torch.optim.SGD(model.parameters(), lr=0.05)
-loss_f = nn.CrossEntropyLoss()
-epoch_num = 200
-for epoch in range(epoch_num):
-    epoch_start_time = time.time()
-    epoch_loss = 0
-    epoch_acc = 0
-    for i, (x_epoch, y_epoch) in enumerate(dataloader):
-        optim.zero_grad()
-        outputs = model(x_epoch)
-        loss = loss_f(outputs, y_epoch.type(torch.LongTensor))
-
-        loss.backward()
-        optim.step()
-
-        epoch_acc += np.sum(
-            np.argmax(outputs.cpu().data.numpy(), axis=1) == y_epoch.numpy())
-        epoch_loss += loss.item()
-
-    print('[%03d/%03d] %2.2f s TA: %3.6f Ls: %3.6f' %
-          (epoch + 1, epoch_num, time.time() - epoch_start_time,
-           epoch_acc / y.__len__(), epoch_loss / y.__len__()))
-
-test_predict = model(x_train)
-test_predict = np.argmax(test_predict.data.numpy(), axis=1)
-test_result = pd.concat([
-    pd.DataFrame({'predict': test_predict}),
-    pd.DataFrame({'label': y_train.numpy()})
-],
-                        axis=1)
-conf_matrix = np.zeros([2, 2])
-conf_matrix = confusion_matrix(test_predict,
-                               y_train.numpy().astype(int),
-                               conf_matrix=conf_matrix)
-conf_matrix = conf_matrix.astype(int)
-test_result = pd.concat([
-    test_result,
-    pd.DataFrame({
-        'label': ['I/NL', 'R'],
-        'I/NL': conf_matrix[0, :],
-        'R': conf_matrix[1, :],
-        # 'NL': conf_matrix[2, :]
-    })
-],
-                        axis=1)
-test_result.to_csv('model/knowledge_mode/load_test_result.csv',
-                   index=True,
-                   sep=',')
Index: 凡/model/linear.py
===================================================================
--- 凡/model/linear.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ 凡/model/linear.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
@@ -1,45 +0,0 @@
-#!/home/chaofan/anaconda3/bin/python
-# -*- encoding: utf-8 -*-
-'''
-@Description:       :
-@Date     :2021/02/05 14:57:09
-@Author      :chaofan
-@version      :1.0
-'''
-import torch
-import torch.nn as nn
-
-
-# 单层线性网络
-class SingleLayerModel(nn.Module):
-    def __init__(self, input_dim, output_dim):
-        super(SingleLayerModel, self).__init__()
-        self.linear1 = nn.Linear(input_dim, output_dim)
-
-    def forward(self, x):
-        output = self.linear1(x)
-        return output
-
-
-class DoubleLayerModel(nn.Module):
-    def __init__(self, input_dim, hidden_dim, output_dim):
-        super(DoubleLayerModel, self).__init__()
-        self.linear1 = nn.Linear(input_dim, hidden_dim)
-        self.linear2 = nn.Linear(hidden_dim, output_dim)
-
-    def forward(self, x):
-        hidden1 = self.linear1(x)
-        activate1 = torch.relu(hidden1)
-        output = self.linear2(activate1)
-        return output
-
-
-class MultiLayerModer(nn.Module):
-    def __init__(self, input_dim, output_dim):
-        super(MultiLayerModer, self).__init__()
-        self.forward_calc = nn.Sequential(nn.Linear(input_dim, 200), nn.ReLU(),
-                                          nn.Linear(200, 200), nn.ReLU(),
-                                          nn.Linear(200, output_dim))
-
-    def forward(self, x):
-        return self.forward_calc(x)
Index: 凡/dataset/classifieddata.py
===================================================================
--- 凡/dataset/classifieddata.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ 凡/dataset/classifieddata.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
@@ -1,130 +0,0 @@
-import json
-import os
-import numpy as np
-import pandas as pd
-
-
-def read_index(type, header='appliance'):
-    with open('data/source/metadata_submetered.json', 'r',
-              encoding='utf8') as load_meta:
-        meta = json.load(load_meta)
-        metadata_len = len(meta)
-        label_index = {}
-        for i in range(metadata_len):
-            try:
-                label = meta[str(i + 1)][header][str(type)]
-            except NameError:
-                print('第{}个样本没有属性{}'.format(i + 1, type))
-            else:
-                if label in label_index.keys():
-                    label_index[label].append(i + 1)
-                else:
-                    label_index[label] = [i + 1]
-        return label_index
-
-
-# test read_index
-# ri = read_index('load')
-# print(ri)
-
-
-def read_correlation(name,
-                     type,
-                     name_header='appliance',
-                     type_header='appliance'):
-    with open('data/source/metadata_submetered.json', 'r',
-              encoding='utf8') as load_meta:
-        meta = json.load(load_meta)
-        metadata_len = len(meta)
-        name_type = {}
-        for i in range(metadata_len):
-            try:
-                name_label = meta[str(i + 1)][name_header][str(name)]
-                type_label = meta[str(i + 1)][type_header][str(type)]
-            except NameError:
-                print('第{}个样本没有属性{}或{}'.format(i + 1, name, type))
-            else:
-                if name_label in name_type.keys():
-                    if type_label in name_type[name_label]:
-                        continue
-                    else:
-                        name_type[name_label].append(type_label)
-                else:
-                    name_type[name_label] = type_label
-        return name_type
-
-
-# # test read_correlation
-# rc = read_correlation('type', 'load')
-# print(rc)
-
-
-def read_processed_data(type,
-                        offset=0,
-                        direaction=0,
-                        each_lenth=1,
-                        feature_select=None,
-                        Transformer=None):
-    meta = None
-    with open('data/source/metadata_submetered.json', 'r',
-              encoding='utf8') as load_meta:
-        meta = json.load(load_meta)
-    dir = 'data/source/submetered_process'
-    csv_list = os.listdir(dir)
-    first_data = pd.read_csv(os.path.join(dir, csv_list[0]))
-    features = first_data.keys()
-    feature_len = 0
-    try:
-        feature_index = features.get_indexer(feature_select)
-        feature_index = feature_index.tolist()
-    except IndexError:
-        print('there is no feature-selected in data')
-    if feature_select is None:
-        feature_len = len(features)
-    else:
-        try:
-            feature_len = len(feature_select)
-        except TypeError:
-            print('feature_select需为所选特征数组')
-    x = np.zeros((len(csv_list) * each_lenth, feature_len))
-    y = np.zeros((len(csv_list) * each_lenth))
-    for i, file in enumerate(csv_list):
-        if feature_select is None:
-            data = pd.read_csv(os.path.join(dir, file))
-        else:
-            data = pd.read_csv(
-                os.path.join(dir, file),
-                usecols=feature_index,
-            )
-        num = file[0:-4]
-        data_len = len(data)
-        try:
-            label = meta[num]['appliance'][type]
-        except TypeError:
-            print('没有该属性')
-        if direaction == 0:
-            for j in range(each_lenth):
-                x[i * each_lenth + j, :] = data.loc[offset + j]
-            if Transformer is not None:
-                y[i * each_lenth + j] = Transformer[label]
-            else:
-                y = y.astype(np.str)
-                y[i * each_lenth + j] = label
-        else:
-            for j in range(each_lenth):
-                x[i * each_lenth + j, :] = data.loc[data_len - offset - j - 1]
-            if Transformer is not None:
-                y[i * each_lenth + j] = Transformer[label]
-            else:
-                y = y.astype(np.str)
-                y[i * each_lenth + j] = label
-
-    return x, y
-
-
-# test
-# x, y = read_processed_data('load')
-# y_onehot = pd.get_dummies(y)
-# y_onehot.head()
-# print(y_onehot)
-# print(pd.value_counts(y, sort=False))
Index: 凡/data/feature_extract/base_features.py
===================================================================
--- 凡/data/feature_extract/base_features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
+++ 凡/data/feature_extract/base_features.py	(revision 4b3aec56f9b7787a67af51a344f2eff28fffb491)
@@ -1,227 +0,0 @@
-import numpy as np
-import pywt
-
-
-class BaseFeatures:
-    """
-    基础特征的父类，包含常见基础特征的计算方法，用于对整段数据进行单次计算
-    """
-    def __init__(self,
-                 is_fft=False,
-                 is_wavelet=False,
-                 sampling_frequency=0,
-                 wt_level=0,
-                 wt_name='db3'):
-        """FeaturesPar类的初始化
-
-        :param is_fft: 是否进行傅里叶计算，True时结果在属性data_fft中
-        :param is_wavelet: 是否需要进行小波变换相关计算，True时结果在属性data_wt中
-        :param sampling_frequency: 采样频率，当要进行傅里叶变换即is_fft为True时需指定
-        :param wt_level: 小波变换层数，当要进行小波变换时需指定
-        :param wt_name: 小波名称，默认为db3，可修改
-        """
-        self.power_frequency = 60  # 电源频率
-        self.__is_fft = is_fft
-        self.__is_wavelet = is_wavelet
-        if self.__is_fft:
-            if sampling_frequency == 0:
-                # 若要做fft，则需确定采样频率的值，否则抛出错误
-                raise Exception('请确定采样频率（sampling_frequency）的值，以便进行FFT计算')
-            else:
-                self.sampling_frequency = sampling_frequency
-        if self.__is_wavelet:
-            if wt_level == 0:
-                # 若要做小波变换，则需确定小波种类和分析的阶数，否则抛出错误
-                raise Exception('请确定小波变换阶数（wt_level）的值，必要时修改小波种类，以便进行小波计算')
-            else:
-                self.wt_level = wt_level
-                self.wt_name = wt_name
-
-    def __call__(self, data):
-        """更新实例的特征
-
-        :param data: 要进行计算的数据
-        :return: 更新后的实例
-        """
-        data = np.array(data)
-        self.__data_source = data  # 原始数据
-        self.__data_mean = self.get_mean(data)  # 数据平均值
-        self.__data_absmean = self.get_absmean(data)  # 数据绝对均值
-        self.__data_pp = self.get_p_p_value(data)  # 数据峰峰值
-        self.__data_rms = self.get_rms(data)  # 数据有效值
-        self.__data_wave_factor = self.get_wave_factor(data)  # 计算波形因数
-        self.__data_pp_rms = self.get_pp_rms(data)  # 计算峰均比
-        self.__data_fft = None
-        self.__data_wt = None
-        self.__data_thd = None
-        if self.__is_wavelet:
-            self.__data_wt = self.get_wt_data(data, self.wt_name,
-                                              self.wt_level)
-        if self.__is_fft:
-            self.__data_fft = {
-                "freq": (self.fft_to_harmonic(data, self.sampling_frequency,
-                                              self.power_frequency))[0],
-                "hm": (self.fft_to_harmonic(data, self.sampling_frequency,
-                                            self.power_frequency))[1],
-                "hp": (self.fft_to_harmonic(data, self.sampling_frequency,
-                                            self.power_frequency))[2]
-            }
-            self.__data_thd = np.mean(np.square(
-                (self.__data_fft["hm"])[2:])) / (self.__data_fft["hm"])[1]
-        return self
-
-    @property
-    def source(self):
-        """设置属性只读"""
-        return self.__data_source
-
-    @property
-    def mean(self):
-        """设置属性只读"""
-        return self.__data_mean
-
-    @property
-    def absmean(self):
-        return self.__data_absmean
-
-    @property
-    def pp(self):
-        """设置属性只读"""
-        return self.__data_pp
-
-    @property
-    def rms(self):
-        """设置属性只读"""
-        return self.__data_rms
-
-    @property
-    def wave_factor(self):
-        """设置属性只读"""
-        return self.__data_wave_factor
-
-    @property
-    def pp_rms(self):
-        """设置属性只读"""
-        return self.__data_pp_rms
-
-    @property
-    def wt(self):
-        """设置属性只读"""
-        return self.__data_wt
-
-    @property
-    def fft(self):
-        """设置属性只读"""
-        return self.__data_fft
-
-    @property
-    def thd(self):
-        """设置属性只读"""
-        return self.__data_thd
-
-    @staticmethod
-    def get_mean(data):
-        """计算数据平均值
-
-        :param data: 要进行计算平均值的数据
-        :return: 平均值
-        """
-        data = np.array(data).reshape(-1)
-        return np.mean(data)
-
-    @staticmethod
-    def get_absmean(data):
-        """计算数据绝对均值
-
-        :param data: 要进行计算绝对均值的数据
-        :return: 绝对均值
-        """
-        data = np.array(data).reshape(-1)
-        return np.mean(np.abs(data))
-
-    @staticmethod
-    def get_p_p_value(data):
-        """计算峰峰值
-
-        :param data: 要进行计算峰峰值的数据
-        :return: 峰峰值
-        """
-        data = np.array(data).reshape(-1)
-        return np.max(data) - np.min(data)
-
-    @staticmethod
-    def get_rms(data):
-        """计算有效值
-
-        :param data: 要进行有效值计算的数据
-        :return: 有效值
-        """
-        square_data = np.square(data)
-        return np.sqrt(np.mean(square_data))
-
-    @staticmethod
-    def get_wave_factor(data):
-        """计算波形因数
-
-        :param data: 要进行波形因数计算的数据
-        :return: 波形因数
-        """
-        return BaseFeatures.get_rms(data) / np.mean(np.abs(data))
-
-    @staticmethod
-    def get_pp_rms(data):
-        """计算均峰比
-
-        :param data: 要进行均峰比计算的数据
-        :return: 均峰比
-        """
-        return BaseFeatures.get_p_p_value(data) / BaseFeatures.get_rms(data)
-
-    @staticmethod
-    def fft_to_harmonic(data, sampling_frequency, power_frequency):
-        """傅里叶计算
-
-        :param data: 要进行傅里叶计算的数据
-        :param sampling_frequency: 数据的采样频率
-        :param power_frequency: 数据的电源频率
-        :return: 第0至31次谐波的频率，对应的谐波有效值和谐波相角
-        """
-        data = np.array(data)
-        index = np.arange(32) * int(
-            np.size(data, 0) / sampling_frequency * power_frequency)
-        x = np.fft.fft(data, np.size(data, 0), axis=0) / np.size(data, 0) * 2
-        x = x[index]
-        x[0] /= np.sqrt(2)
-        freq = np.fft.fftfreq(np.size(data, 0), 1 / sampling_frequency)
-        freq = freq[index]
-        hp = np.angle(x) / np.pi * 180
-        hm = np.abs(x) / np.sqrt(2)
-        if hp[0] > 90:
-            hp[0] -= 180
-            hm[0] = -hm[0]
-        return freq, hm, hp
-
-    @staticmethod
-    def get_wt_data(data, wt_name, wave_level):
-        """离散小波变换计算
-
-        :param data: 要进行小波变换的数据
-        :param wt_name: 所使用的小波基名称
-        :param wave_level: 要进行的小波分析层数
-        :return: 小波系数和各层小波能量等
-        """
-        coeffs = pywt.wavedec(data, wt_name, level=wave_level)  # 小波系数获取
-        cd_list = []
-        cd_e_list = []
-        for i in range(len(coeffs) - 1):
-            cd_list.append(coeffs[len(coeffs) - i - 1])
-            cd_e_list.append(np.mean(np.square(coeffs[len(coeffs) - i - 1])))
-        wt_result = {
-            "Coeffs": coeffs,  # 小波系数，coeffs[0]是近似系数，coeffs[1]是最底层细节系数
-            "CA": coeffs[0],  # 近似小波系数
-            "CD": cd_list,  # 细节小波系数
-            "CD_E_list": cd_e_list,  # 各层细节系数能量值
-            "CA_E": np.mean(np.square(coeffs[0])),  # 近似系数能量
-            "CD_E": np.sum(cd_e_list)  # 细节系数能量
-        }
-        return wt_result
